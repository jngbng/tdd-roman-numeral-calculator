# TDD Exercise Roman Numeral Calculator

로마 숫자 덧셈 계산기를 만들어보면서 TDD를 연습한다.

Taken from https://github.com/hjwp/tdd-roman-numeral-calculator/

## 문제 설명

문자셋:

| 로만 글자 | 아라비아 숫자 |
| --- | --- |
| I | 1 |
| V | 5 |
| X | 10 |
| L | 50 |
| C | 100 |
| D | 500 |
| M | 1000 |

**룰1: 같은 문자가 반복되면 그 값을 더한다.**

```python
X   ⇒  10
XX  ⇒ 20
XXX  ⇒ 30
C ⇒ 100
CCC ⇒ 300
```

단, `V`, `L`, `D` 는 반복될 수 없다.

```python
VV ≠ 10
DDD ≠ 150
```

**룰2: 큰 문자 뒤에 작은 문자가 나타나면, 그 숫자들을 다 더한다.**

```python
DXXX  ⇒ 500 + 10 + 10 + 10 = 530
MCC ⇒ 1000 + 100 + 100 = 1200
```

**룰3: 같은 문자를 4번 이상 반복하지 않는다. (4, 9, 40, 90, 400, 900은 전용 표현을 쓴다.)**

| 숫자 | 틀린 표현 | 맞는 표현 |
| --- | --- | --- |
| 4 | IIII | IV ( -1 + 5) |
| 9 | VIIII | IX (-1 + 10) |
| 40 | XXXX | XL (-10 + 50) |
| 90 | LXXX | XC (-10 + 100) |

다른 창의적인 조합은 허용하지 않는다.

| 숫자 | 틀린 표현 | 맞는 표현 |
| --- | --- | --- |
| 45 | VL  ( -5 + 50) | XLV (40 + 5) |
| 950 | LM ( -50 + 1000) | CML (900 + 50) |
| 999 | IM (-1 + 1000) | CM XC IX (900 + 90 + 9) |

**룰4: 이들을 조합하여 숫자를 표현할 수 있다.**

```python
DCXCV => 500 100 10 100 5 => 500 + 100 + (-10 + 100) + 5 = 695
```

**룰5: 문자 위에 선(bar)을 그으면 1000을 곱한 것으로 해석한다.**
이건 구현하지 않음.

```
_
V = 5,000
_
X = 10,000
_
L = 50,000
...
```


## 실행

- [watchexec](https://github.com/watchexec/watchexec) 설치.
- pytest 설치.

Start test:

```
$ bash run_test.sh
```

이제 `roman_numeral_calculator.add` 함수를 완성해보자.

## 설명

알고리즘을 설계한 후 한번에 다 작성한 후 테스트가 모두 성공하는지를 보는게 아니라,

당장에 발생하는 에러나 테스트 실패만을 최소한의 스탭으로 해결해 나가면서 진행해본다.

## 개인적 후기

TDD의 가치를 느껴보기에 좋은 예제는 아닌 것 같다. (저자가 이 예제를 버린 이유를 알 것 같다.)

알고리즘 설계/구현 문제를 굳이 작은 스탭으로 brute-force 식으로 진행하면서, 틈틈히 리펙토링을 한다고 원하는 알고리즘이 나오진 않을 것 같기 때문이다. TDD는 불안감을 덜어내기 위한 기술인데, 이런식으로 마구잡이로 진행하다가 어쩌다 테스트가 다 통과한다고 불안감이 덜어지지도 않을 것 같다. (테스트가 정말 모든 edge 케이스를 커버한거 맞나 하는 불안감.) 이 예제야 이렇게 해도 어떻게 만들 수 있다지만, 동적계획법이나 그래프 순회 같은 문제는 이런 식으로 진행하면 원하는 코드에 도달할 수 있을까? 그리고 이득이 있을까? 작은 스탭으로 쪼개서 진행하는 내공이 너무 부족해서 이렇게 느끼는 것일지도 모르겠다.
